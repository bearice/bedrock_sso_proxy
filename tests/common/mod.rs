use axum::{
    body::Body,
    http::{Method, Request, StatusCode},
    Router,
};
use bedrock_sso_proxy::{
    auth::{jwt::OAuthClaims, middleware::UserExtractor},
    database::entities::UserRecord,
    Config, Server,
};
use chrono::Utc;
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use std::time::{SystemTime, UNIX_EPOCH};
use tower::ServiceExt;
use uuid::Uuid;

/// Unified test harness that handles app setup and token management
pub struct TestHarness {
    #[allow(dead_code)]
    pub config: Config,
    pub app: Router,
    pub jwt_secret: String,
    pub server: Server,
}

#[allow(dead_code)]
impl TestHarness {
    /// Create test harness with default secret
    pub async fn new() -> Self {
        Self::with_secret("test-secret-123").await
    }

    /// Create test harness for security tests with mock AWS
    pub async fn new_for_security_tests() -> Self {
        let mut config = Config::default();
        config.jwt.secret = "test-secret-123".to_string();
        config.api_keys.enabled = true;
        config.admin.emails = vec!["admin@admin.example.com".to_string()];

        // Use a unique, shared, in-memory SQLite database
        let db_name = format!("file:memdb_{}?mode=memory&cache=shared", Uuid::new_v4());
        config.database.url = db_name;
        config.database.enabled = true;

        // Mock AWS for security tests
        let server = bedrock_sso_proxy::Server::new(config.clone())
            .await
            .unwrap(); // This needs to be adapted for mock aws
        let app = server.create_app();

        Self {
            jwt_secret: "test-secret-123".to_string(),
            config,
            app,
            server,
        }
    }

    /// Create test harness with custom secret
    pub async fn with_secret(secret: &str) -> Self {
        let mut config = Config::default();
        config.jwt.secret = secret.to_string();
        config.database.enabled = true;
        config.api_keys.enabled = false;
        config.admin.emails = vec!["admin@admin.example.com".to_string()];

        // Use a unique, shared, in-memory SQLite database
        let db_name = format!("file:memdb_{}?mode=memory&cache=shared", Uuid::new_v4());
        config.database.url = db_name;

        let server = Server::new(config.clone()).await.unwrap();
        let app = server.create_app();

        Self {
            jwt_secret: secret.to_string(),
            config,
            app,
            server,
        }
    }

    /// Create test harness with PostgreSQL database
    pub async fn with_postgres(postgres_db: &PostgresTestDb) -> Self {
        Self::with_postgres_and_secret(postgres_db, "test-secret-123").await
    }

    /// Create test harness with PostgreSQL database and custom secret
    pub async fn with_postgres_and_secret(postgres_db: &PostgresTestDb, secret: &str) -> Self {
        let mut config = Config::default();
        config.jwt.secret = secret.to_string();
        config.database.url = postgres_db.database_url.clone();
        config.database.enabled = true;
        config.api_keys.enabled = false;
        config.admin.emails = vec!["admin@admin.example.com".to_string()];

        let server = Server::new(config.clone()).await.unwrap();
        let app = server.create_app();

        Self {
            jwt_secret: secret.to_string(),
            config,
            app,
            server,
        }
    }

    /// Create JWT token from claims
    pub fn create_token(&self, claims: &OAuthClaims) -> String {
        encode(
            &Header::default(),
            claims,
            &EncodingKey::from_secret(self.jwt_secret.as_ref()),
        )
        .unwrap()
    }

    /// Create test user in database
    pub async fn create_test_user(&self, email: &str) -> i32 {
        let user = UserRecord {
            id: 0, // Will be auto-generated by database
            provider_user_id: format!("test_user_{}", email.replace(['@', '.'], "_")),
            provider: "test".to_string(),
            email: email.to_string(),
            display_name: Some("Test User".to_string()),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            last_login: Some(Utc::now()),
            ..Default::default()
        };
        self.server.database.users().upsert(&user).await.unwrap()
    }

    /// Create JWT token for integration tests
    #[allow(dead_code)]
    pub fn create_integration_token(&self, sub: i32) -> String {
        let claims = OAuthClaims::new(sub, 3600);
        self.create_token(&claims)
    }

    /// Create JWT token for security tests
    #[allow(dead_code)]
    pub fn create_security_token(&self, sub: i32, exp_offset: i64) -> String {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;
        let exp = (now + exp_offset) as usize;

        let mut claims = OAuthClaims::new(sub, 3600);
        claims.exp = exp;
        self.create_token(&claims)
    }

    /// Create JWT token with custom expiry
    #[allow(dead_code)]
    pub fn create_token_with_expiry(&self, sub: i32, exp: u64) -> String {
        let claims: OAuthClaims = OAuthClaims::new(sub, exp);
        self.create_token(&claims)
    }

    /// Make request using the test app
    pub async fn make_request(&self, request: Request<Body>) -> axum::response::Response {
        self.app.clone().oneshot(request).await.unwrap()
    }

    /// Verify JWT token
    #[allow(dead_code)]
    pub fn verify_token(&self, token: &str) -> Result<OAuthClaims, jsonwebtoken::errors::Error> {
        let mut validation = Validation::new(Algorithm::HS256);
        validation.validate_exp = true;

        let token_data = decode::<OAuthClaims>(
            token,
            &DecodingKey::from_secret(self.jwt_secret.as_ref()),
            &validation,
        )?;

        Ok(token_data.claims)
    }

    /// Create API key for testing (if API keys are enabled)
    #[allow(dead_code)]
    pub async fn create_test_api_key(&self, user_id: i32, name: &str) -> String {
        use bedrock_sso_proxy::auth::api_key::ApiKey;

        let (api_key, key_string) = ApiKey::new(user_id, name.to_string(), None);
        let _key_id = self
            .server
            .database
            .api_keys()
            .store(&api_key)
            .await
            .unwrap();
        key_string
    }
}

/// Unified request builder for both test suites
pub struct RequestBuilder;

#[allow(dead_code)]
impl RequestBuilder {
    /// Health check with auth
    pub fn health_with_auth(token: &str) -> Request<Body> {
        Request::builder()
            .uri("/health")
            .header("Authorization", format!("Bearer {token}"))
            .body(Body::empty())
            .unwrap()
    }

    /// Health check with query parameter and auth
    #[allow(dead_code)]
    pub fn health_with_check_and_auth(check_type: &str, token: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/health?check={check_type}"))
            .header("Authorization", format!("Bearer {token}"))
            .body(Body::empty())
            .unwrap()
    }

    /// Model invoke with auth
    pub fn invoke_model_with_auth(model_id: &str, token: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{model_id}/invoke"))
            .method("POST")
            .header("Authorization", format!("Bearer {token}"))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Model invoke streaming with auth
    pub fn invoke_streaming_with_auth(model_id: &str, token: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!(
                "/bedrock/model/{model_id}/invoke-with-response-stream"
            ))
            .method("POST")
            .header("Authorization", format!("Bearer {token}"))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Custom request with method, headers, and body
    #[allow(dead_code)]
    pub fn custom_request(
        uri: &str,
        method: Method,
        token: &str,
        headers: &[(&str, &str)],
        body: &str,
    ) -> Request<Body> {
        let mut builder = Request::builder()
            .uri(uri)
            .method(method)
            .header("Authorization", format!("Bearer {token}"))
            .header("Content-Type", "application/json");

        for (name, value) in headers {
            builder = builder.header(*name, *value);
        }

        builder.body(Body::from(body.to_string())).unwrap()
    }

    /// Request with custom content type
    #[allow(dead_code)]
    pub fn with_content_type(
        uri: &str,
        method: Method,
        token: &str,
        content_type: &str,
        body: &str,
    ) -> Result<Request<Body>, Box<dyn std::error::Error>> {
        Ok(Request::builder()
            .uri(uri)
            .method(method)
            .header("Authorization", format!("Bearer {token}"))
            .header("Content-Type", content_type)
            .body(Body::from(body.to_string()))?)
    }

    /// Model invoke with API key via X-API-Key header
    #[allow(dead_code)]
    pub fn invoke_model_with_api_key_header(
        model_id: &str,
        api_key: &str,
        body: &str,
    ) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{model_id}/invoke"))
            .method("POST")
            .header("X-API-Key", api_key)
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Model invoke with API key via Authorization Bearer header
    #[allow(dead_code)]
    pub fn invoke_model_with_api_key_bearer(
        model_id: &str,
        api_key: &str,
        body: &str,
    ) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{model_id}/invoke"))
            .method("POST")
            .header("Authorization", format!("Bearer {api_key}"))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }
}

/// PostgreSQL test utilities for temporary database management
pub struct PostgresTestDb {
    pub database_name: String,
    pub database_url: String,
}

#[allow(dead_code)]
impl PostgresTestDb {
    /// Create a new temporary PostgreSQL database for testing
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let database_name = format!("test_db_{}", Uuid::new_v4().to_string().replace('-', "_"));
        let base_url = std::env::var("TEST_POSTGRES_URL")
            .unwrap_or_else(|_| "postgresql://localhost/postgres".to_string());
        let base_without_db = base_url.trim_end_matches("/postgres");
        let database_url = format!("{base_without_db}/{database_name}");

        // Connect to postgres database to create the test database
        let pool = sqlx::postgres::PgPool::connect(&base_url).await?;

        // Create the temporary database
        sqlx::query(&format!("CREATE DATABASE \"{database_name}\""))
            .execute(&pool)
            .await?;

        pool.close().await;

        Ok(Self {
            database_name,
            database_url,
        })
    }

    /// Clean up the temporary database
    pub async fn cleanup(&self) -> Result<(), Box<dyn std::error::Error>> {
        let base_url = std::env::var("TEST_POSTGRES_URL")
            .unwrap_or_else(|_| "postgresql://localhost/postgres".to_string());
        let pool = sqlx::postgres::PgPool::connect(&base_url).await?;

        // Terminate any existing connections to the database
        sqlx::query(&format!(
            "SELECT pg_terminate_backend(pid)
             FROM pg_stat_activity
             WHERE datname = '{}' AND pid <> pg_backend_pid()",
            self.database_name
        ))
        .execute(&pool)
        .await?;

        // Drop the temporary database
        sqlx::query(&format!("DROP DATABASE \"{}\"", self.database_name))
            .execute(&pool)
            .await?;

        pool.close().await;
        Ok(())
    }
}

impl Drop for PostgresTestDb {
    fn drop(&mut self) {
        // Attempt cleanup in drop, but don't panic if it fails
        // The database will be cleaned up when the postgres server restarts
        let database_name = self.database_name.clone();
        tokio::spawn(async move {
            let base_url = std::env::var("TEST_POSTGRES_URL")
                .unwrap_or_else(|_| "postgresql://localhost/postgres".to_string());
            if let Ok(pool) = sqlx::postgres::PgPool::connect(&base_url).await {
                let _ = sqlx::query(&format!(
                    "SELECT pg_terminate_backend(pid)
                     FROM pg_stat_activity
                     WHERE datname = '{database_name}' AND pid <> pg_backend_pid()"
                ))
                .execute(&pool)
                .await;

                let _ = sqlx::query(&format!("DROP DATABASE \"{database_name}\""))
                    .execute(&pool)
                    .await;

                pool.close().await;
            }
        });
    }
}

/// Helper functions for common test patterns
pub mod helpers {
    use super::*;

    /// Assert response status with context
    #[allow(dead_code)]
    pub fn assert_status_with_context(
        response: &axum::response::Response,
        expected: StatusCode,
        context: &str,
    ) {
        assert_eq!(
            response.status(),
            expected,
            "Expected {} for {}, got {}",
            expected,
            context,
            response.status()
        );
    }

    /// Assert response status is one of several acceptable values
    #[allow(dead_code)]
    pub fn assert_status_in(
        response: &axum::response::Response,
        acceptable: &[StatusCode],
        context: &str,
    ) {
        assert!(
            acceptable.contains(&response.status()),
            "Expected one of {:?} for {}, got {}",
            acceptable,
            context,
            response.status()
        );
    }
}
