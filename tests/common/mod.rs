use axum::{
    Router,
    body::Body,
    http::{Method, Request, StatusCode},
};
use bedrock_sso_proxy::{
    Config, Server, auth::OAuthClaims, database::entities::UserRecord,
    test_utils::TestServerBuilder,
};
use chrono::Utc;
use jsonwebtoken::{Algorithm, DecodingKey, EncodingKey, Header, Validation, decode, encode};
use std::time::{SystemTime, UNIX_EPOCH};
use tower::ServiceExt;

/// Unified test harness that handles app setup and token management
pub struct TestHarness {
    #[allow(dead_code)]
    pub config: Config,
    pub app: Router,
    pub jwt_secret: String,
    pub server: Server,
}

impl TestHarness {
    /// Create test harness with default secret
    pub async fn new() -> Self {
        Self::with_secret("test-secret-123").await
    }

    /// Create test harness for security tests with mock AWS
    pub async fn new_for_security_tests() -> Self {
        Self::with_secret_and_mock_aws("test-secret-123").await
    }

    /// Create test harness with custom secret
    pub async fn with_secret(secret: &str) -> Self {
        let mut config = Config::default();
        config.jwt.secret = secret.to_string();
        config.database.enabled = true; // Enable database for testing

        // Disable API keys for security tests to focus on JWT authentication
        config.api_keys.enabled = false;

        // Add test AWS credentials for integration tests
        config.aws.access_key_id = Some("test-access-key".to_string());
        config.aws.secret_access_key = Some("test-secret-key".to_string());

        let server = TestServerBuilder::new()
            .with_config(config.clone())
            .with_jwt_secret(secret.to_string()) // Ensure server uses the same secret
            .build()
            .await;

        let app = server.create_app();

        Self {
            jwt_secret: secret.to_string(), // Use the actual secret, not the config one
            config,
            app,
            server,
        }
    }

    /// Create test harness with custom secret and mock AWS for security testing
    pub async fn with_secret_and_mock_aws(secret: &str) -> Self {
        let mut config = Config::default();
        config.jwt.secret = secret.to_string();
        config.database.enabled = true; // Enable database for testing

        // Enable both JWT and API key authentication for comprehensive security testing
        config.api_keys.enabled = true;

        // Add test AWS credentials for integration tests (not used with mock)
        config.aws.access_key_id = Some("test-access-key".to_string());
        config.aws.secret_access_key = Some("test-secret-key".to_string());

        let server = TestServerBuilder::new()
            .with_config(config.clone())
            .with_jwt_secret(secret.to_string())
            .with_mock_aws() // Use mock AWS client for security tests
            .build()
            .await;

        let app = server.create_app();

        Self {
            jwt_secret: secret.to_string(),
            config,
            app,
            server,
        }
    }

    /// Create JWT token from claims
    pub fn create_token(&self, claims: &OAuthClaims) -> String {
        encode(
            &Header::default(),
            claims,
            &EncodingKey::from_secret(self.jwt_secret.as_ref()),
        )
        .unwrap()
    }

    /// Create test user in database
    pub async fn create_test_user(&self, email: &str) -> i32 {
        let user = UserRecord {
            id: 0, // Will be auto-generated by database
            provider_user_id: format!("test_user_{}", email.replace(['@', '.'], "_")),
            provider: "test".to_string(),
            email: email.to_string(),
            display_name: Some("Test User".to_string()),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            last_login: Some(Utc::now()),
        };
        self.server.database.users().upsert(&user).await.unwrap()
    }

    /// Create JWT token for integration tests
    #[allow(dead_code)]
    pub fn create_integration_token(&self, sub: i32) -> String {
        let claims = OAuthClaims::new(sub, 3600);
        self.create_token(&claims)
    }

    /// Create JWT token for security tests
    #[allow(dead_code)]
    pub fn create_security_token(&self, sub: i32, exp_offset: i64) -> String {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;
        let exp = (now + exp_offset) as usize;

        let mut claims = OAuthClaims::new(sub, 3600);
        claims.exp = exp;
        self.create_token(&claims)
    }

    /// Create JWT token with custom expiry
    #[allow(dead_code)]
    pub fn create_token_with_expiry(&self, sub: i32, exp: u64) -> String {
        let claims: OAuthClaims = OAuthClaims::new(sub, exp);
        self.create_token(&claims)
    }

    /// Make request using the test app
    pub async fn make_request(&self, request: Request<Body>) -> axum::response::Response {
        self.app.clone().oneshot(request).await.unwrap()
    }

    /// Verify JWT token
    #[allow(dead_code)]
    pub fn verify_token(&self, token: &str) -> Result<OAuthClaims, jsonwebtoken::errors::Error> {
        let mut validation = Validation::new(Algorithm::HS256);
        validation.validate_exp = true;

        let token_data = decode::<OAuthClaims>(
            token,
            &DecodingKey::from_secret(self.jwt_secret.as_ref()),
            &validation,
        )?;

        Ok(token_data.claims)
    }

    /// Create API key for testing (if API keys are enabled)
    #[allow(dead_code)]
    pub async fn create_test_api_key(&self, user_id: i32, name: &str) -> String {
        use bedrock_sso_proxy::auth::api_key::ApiKey;
        
        let (api_key, key_string) = ApiKey::new(user_id, name.to_string(), None);
        let _key_id = self.server.database.api_keys().store(&api_key).await.unwrap();
        key_string
    }
}

/// Unified request builder for both test suites
pub struct RequestBuilder;

impl RequestBuilder {
    /// Health check with auth
    pub fn health_with_auth(token: &str) -> Request<Body> {
        Request::builder()
            .uri("/health")
            .header("Authorization", format!("Bearer {}", token))
            .body(Body::empty())
            .unwrap()
    }

    /// Health check with query parameter and auth
    #[allow(dead_code)]
    pub fn health_with_check_and_auth(check_type: &str, token: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/health?check={}", check_type))
            .header("Authorization", format!("Bearer {}", token))
            .body(Body::empty())
            .unwrap()
    }

    /// Model invoke with auth
    pub fn invoke_model_with_auth(model_id: &str, token: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{}/invoke", model_id))
            .method("POST")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Model invoke streaming with auth
    #[allow(dead_code)]
    pub fn invoke_streaming_with_auth(model_id: &str, token: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!(
                "/bedrock/model/{}/invoke-with-response-stream",
                model_id
            ))
            .method("POST")
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Custom request with method, headers, and body
    #[allow(dead_code)]
    pub fn custom_request(
        uri: &str,
        method: Method,
        token: &str,
        headers: &[(&str, &str)],
        body: &str,
    ) -> Request<Body> {
        let mut builder = Request::builder()
            .uri(uri)
            .method(method)
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json");

        for (name, value) in headers {
            builder = builder.header(*name, *value);
        }

        builder.body(Body::from(body.to_string())).unwrap()
    }

    /// Request with custom content type
    #[allow(dead_code)]
    pub fn with_content_type(
        uri: &str,
        method: Method,
        token: &str,
        content_type: &str,
        body: &str,
    ) -> Result<Request<Body>, Box<dyn std::error::Error>> {
        Ok(Request::builder()
            .uri(uri)
            .method(method)
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", content_type)
            .body(Body::from(body.to_string()))?)
    }

    /// Model invoke with API key via X-API-Key header
    #[allow(dead_code)]
    pub fn invoke_model_with_api_key_header(model_id: &str, api_key: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{}/invoke", model_id))
            .method("POST")
            .header("X-API-Key", api_key)
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }

    /// Model invoke with API key via Authorization Bearer header
    #[allow(dead_code)]
    pub fn invoke_model_with_api_key_bearer(model_id: &str, api_key: &str, body: &str) -> Request<Body> {
        Request::builder()
            .uri(format!("/bedrock/model/{}/invoke", model_id))
            .method("POST")
            .header("Authorization", format!("Bearer {}", api_key))
            .header("Content-Type", "application/json")
            .body(Body::from(body.to_string()))
            .unwrap()
    }
}

/// Helper functions for common test patterns
pub mod helpers {
    use super::*;

    /// Assert response status with context
    #[allow(dead_code)]
    pub fn assert_status_with_context(
        response: &axum::response::Response,
        expected: StatusCode,
        context: &str,
    ) {
        assert_eq!(
            response.status(),
            expected,
            "Expected {} for {}, got {}",
            expected,
            context,
            response.status()
        );
    }

    /// Assert response status is one of several acceptable values
    #[allow(dead_code)]
    pub fn assert_status_in(
        response: &axum::response::Response,
        acceptable: &[StatusCode],
        context: &str,
    ) {
        assert!(
            acceptable.contains(&response.status()),
            "Expected one of {:?} for {}, got {}",
            acceptable,
            context,
            response.status()
        );
    }
}
